name: Duplicate Issue Detection

on:
  issues:
    types: [opened]

permissions:
  issues: write

jobs:
  check-duplicates:
    runs-on: ubuntu-latest
    
    steps:
      - name: Check for Duplicate Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title.toLowerCase().trim();
            const issueBody = (issue.body || '').toLowerCase().trim();
            const issueLabels = issue.labels.map(label => label.name);
            
            // Configuration
            const SIMILARITY_THRESHOLD = 0.80; // 80% similarity threshold
            const PROTECTED_LABELS = ['critical', 'security', 'urgent', 'high-priority'];
            
            // Skip if issue has protected labels
            const hasProtectedLabel = issueLabels.some(label => 
              PROTECTED_LABELS.includes(label.toLowerCase())
            );
            
            if (hasProtectedLabel) {
              console.log(`Issue #${issueNumber} has protected label. Skipping duplicate check.`);
              return;
            }
            
            // Get issue category (bug, enhancement, feature)
            const issueCategory = issueLabels.find(label => 
              ['bug', 'enhancement', 'feature'].includes(label.toLowerCase())
            );
            
            // Levenshtein distance algorithm for fuzzy string matching
            function levenshteinDistance(str1, str2) {
              const matrix = [];
              
              for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
              }
              
              for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
              }
              
              for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                  if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                  } else {
                    matrix[i][j] = Math.min(
                      matrix[i - 1][j - 1] + 1,
                      matrix[i][j - 1] + 1,
                      matrix[i - 1][j] + 1
                    );
                  }
                }
              }
              
              return matrix[str2.length][str1.length];
            }
            
            // Calculate similarity percentage
            function calculateSimilarity(str1, str2) {
              if (!str1 || !str2) return 0;
              
              const distance = levenshteinDistance(str1, str2);
              const maxLength = Math.max(str1.length, str2.length);
              
              if (maxLength === 0) return 1;
              
              return 1 - (distance / maxLength);
            }
            
            // Normalize text for comparison
            function normalizeText(text) {
              return text
                .toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            }
            
            // Fetch all open issues
            const { data: openIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            let mostSimilarIssue = null;
            let highestSimilarity = 0;
            
            // Compare with existing open issues
            for (const existingIssue of openIssues) {
              // Skip the current issue and pull requests
              if (existingIssue.number === issueNumber || existingIssue.pull_request) {
                continue;
              }
              
              const existingLabels = existingIssue.labels.map(label => label.name);
              const existingCategory = existingLabels.find(label => 
                ['bug', 'enhancement', 'feature'].includes(label.toLowerCase())
              );
              
              // Only compare issues with the same category
              if (issueCategory && existingCategory && issueCategory !== existingCategory) {
                continue;
              }
              
              const existingTitle = normalizeText(existingIssue.title);
              const existingBody = normalizeText(existingIssue.body || '');
              
              const normalizedIssueTitle = normalizeText(issueTitle);
              const normalizedIssueBody = normalizeText(issueBody);
              
              // Calculate weighted similarity (title: 40%, body: 60%)
              const titleSimilarity = calculateSimilarity(normalizedIssueTitle, existingTitle);
              const bodySimilarity = calculateSimilarity(normalizedIssueBody, existingBody);
              
              const overallSimilarity = (titleSimilarity * 0.4) + (bodySimilarity * 0.6);
              
              console.log(`Comparing with #${existingIssue.number}: Title=${(titleSimilarity * 100).toFixed(2)}%, Body=${(bodySimilarity * 100).toFixed(2)}%, Overall=${(overallSimilarity * 100).toFixed(2)}%`);
              
              if (overallSimilarity > highestSimilarity) {
                highestSimilarity = overallSimilarity;
                mostSimilarIssue = existingIssue;
              }
            }
            
            // If similarity exceeds threshold, close as duplicate
            if (highestSimilarity >= SIMILARITY_THRESHOLD && mostSimilarIssue) {
              console.log(`Duplicate detected! Issue #${issueNumber} is ${(highestSimilarity * 100).toFixed(2)}% similar to #${mostSimilarIssue.number}`);
              
              // Add duplicate label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['duplicate']
              });
              
              // Add comment explaining the closure
              const comment = 'ðŸ‘‹ Thank you for creating this issue!\n\n' +
                `However, this appears to be a duplicate of #${mostSimilarIssue.number} (${(highestSimilarity * 100).toFixed(0)}% similarity detected).\n\n` +
                `**Original Issue:** #${mostSimilarIssue.number} - ${mostSimilarIssue.title}\n\n` +
                'To avoid fragmenting the discussion, we\'re closing this issue. Please feel free to:\n' +
                `- ðŸ‘€ Follow the original issue for updates\n` +
                `- ðŸ’¬ Add your comments or additional context to #${mostSimilarIssue.number}\n` +
                '- ðŸ”„ Reopen this issue if you believe it was incorrectly flagged as a duplicate\n\n' +
                'For further communication, join our Discord server: https://discord.gg/tSqtvHUJzE\n\n' +
                '---\n' +
                '*This action was performed automatically by our duplicate detection workflow.*';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: comment
              });
              
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed',
                state_reason: 'not_planned'
              });
              
              console.log(`Issue #${issueNumber} closed as duplicate of #${mostSimilarIssue.number}`);
            } else {
              console.log(`No duplicate found. Highest similarity: ${(highestSimilarity * 100).toFixed(2)}%`);
            }
